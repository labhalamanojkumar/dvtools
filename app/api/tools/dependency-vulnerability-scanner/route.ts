import { NextRequest, NextResponse } from "next/server";
import { LicenseIssue } from "@/types";

// Mock vulnerability database - in a real implementation, this would connect to services like:
// - National Vulnerability Database (NVD)
// - GitHub Security Advisories
// - Package manager security feeds
const MOCK_VULNERABILITIES = {
  "react": [
    {
      cve: "CVE-2023-1234",
      severity: "high",
      cvssScore: 7.5,
      description: "Cross-site scripting vulnerability in React component rendering",
      published: "2023-06-15",
      fixedVersion: "18.2.1",
      references: ["https://github.com/facebook/react/security/advisories/GHSA-1234-5678-9abc"]
    }
  ],
  "lodash": [
    {
      cve: "CVE-2022-5678",
      severity: "medium",
      cvssScore: 5.3,
      description: "Prototype pollution vulnerability in utility functions",
      published: "2022-11-20",
      fixedVersion: "4.17.21",
      references: ["https://github.com/lodash/lodash/security/advisories/GHSA-5678-9abc-def0"]
    }
  ],
  "express": [
    {
      cve: "CVE-2023-9012",
      severity: "critical",
      cvssScore: 9.1,
      description: "Remote code execution vulnerability in Express.js middleware",
      published: "2023-08-10",
      fixedVersion: "4.18.3",
      references: ["https://github.com/expressjs/express/security/advisories/GHSA-9012-3456-789b"]
    }
  ]
};

const MOCK_PACKAGE_VERSIONS = {
  "react": { latest: "18.2.0", published: "2023-10-01" },
  "lodash": { latest: "4.17.21", published: "2023-09-15" },
  "express": { latest: "4.18.2", published: "2023-08-20" },
  "@types/node": { latest: "20.8.0", published: "2023-10-05" },
  "typescript": { latest: "5.2.2", published: "2023-09-30" }
};

const MOCK_LICENSES = {
  "react": "MIT",
  "lodash": "MIT",
  "express": "MIT",
  "@types/node": "MIT",
  "typescript": "Apache-2.0"
};

interface Vulnerability {
  id: string;
  package: string;
  version: string;
  cve: string;
  severity: "critical" | "high" | "medium" | "low";
  cvssScore: number;
  description: string;
  published: string;
  fixedVersion?: string;
  references: string[];
}

interface OutdatedPackage {
  name: string;
  currentVersion: string;
  latestVersion: string;
  type: "major" | "minor" | "patch";
  published: string;
}

function parsePackageJson(content: string) {
  try {
    const pkg = JSON.parse(content);
    const dependencies = { ...pkg.dependencies, ...pkg.devDependencies };
    return Object.entries(dependencies).map(([name, version]) => ({
      name,
      version: (version as string).replace(/[\^~]/g, ""),
    }));
  } catch {
    return [];
  }
}

function parseRequirementsTxt(content: string) {
  return content
    .split("\n")
    .map(line => line.trim())
    .filter(line => line && !line.startsWith("#"))
    .map(line => {
      const match = line.match(/^([a-zA-Z0-9_-]+)([=<>~!]+)(.+)$/);
      if (match) {
        return { name: match[1], version: match[3] };
      }
      return null;
    })
    .filter(Boolean) as { name: string; version: string }[];
}

function parsePomXml(content: string) {
  // Simple XML parsing for Maven dependencies
  const dependencies: { name: string; version: string }[] = [];
  const depRegex = /<dependency>[\s\S]*?<groupId>([^<]+)<\/groupId>[\s\S]*?<artifactId>([^<]+)<\/artifactId>[\s\S]*?<version>([^<]+)<\/version>/g;

  let match;
  while ((match = depRegex.exec(content)) !== null) {
    dependencies.push({
      name: `${match[1]}:${match[2]}`,
      version: match[3],
    });
  }

  return dependencies;
}

function parseManualInput(content: string) {
  return content
    .split("\n")
    .map(line => line.trim())
    .filter(line => line)
    .map(line => {
      // Handle various formats: package@version, package==version, package=version
      const match = line.match(/^([a-zA-Z0-9_.-]+)[@=]{1,2}(.+)$/);
      if (match) {
        return { name: match[1], version: match[2] };
      }
      return null;
    })
    .filter(Boolean) as { name: string; version: string }[];
}

function compareVersions(current: string, latest: string): "major" | "minor" | "patch" {
  const currentParts = current.split(".").map(Number);
  const latestParts = latest.split(".").map(Number);

  if (latestParts[0] > currentParts[0]) return "major";
  if (latestParts[1] > currentParts[1]) return "minor";
  if (latestParts[2] > currentParts[2]) return "patch";

  return "patch"; // Same version
}

function checkLicenseCompatibility(license: string): { compatibility: "compatible" | "incompatible" | "unknown"; issues: string[] } {
  const incompatibleLicenses = ["GPL-3.0", "AGPL-3.0", "LGPL-2.1"];
  const issues: string[] = [];

  if (incompatibleLicenses.includes(license)) {
    issues.push("License may be incompatible with commercial use");
    return { compatibility: "incompatible", issues };
  }

  if (!license || license === "UNKNOWN") {
    issues.push("License information not available");
    return { compatibility: "unknown", issues };
  }

  return { compatibility: "compatible", issues: [] };
}

export async function POST(request: NextRequest) {
  try {
    const formData = await request.formData();
    const input = formData.get("input") as string;
    const scanOptions = JSON.parse(formData.get("scanOptions") as string || "[]");
    const packageManager = formData.get("packageManager") as string;
    const files = formData.getAll("files") as File[];

    const startTime = Date.now();
    const allDependencies: { name: string; version: string }[] = [];

    // Parse input based on type
    if (input && input.trim()) {
      allDependencies.push(...parseManualInput(input));
    }

    // Parse uploaded files
    for (const file of files) {
      try {
        const text = await file.text();

        if (file.name === "package.json" || file.name.endsWith(".json")) {
          allDependencies.push(...parsePackageJson(text));
        } else if (file.name === "requirements.txt" || file.name.endsWith(".txt")) {
          allDependencies.push(...parseRequirementsTxt(text));
        } else if (file.name === "pom.xml" || file.name.endsWith(".xml")) {
          allDependencies.push(...parsePomXml(text));
        }
      } catch (error) {
        console.error(`Error parsing file ${file.name}:`, error);
      }
    }

    // Remove duplicates
    const uniqueDeps = allDependencies.filter((dep, index, self) =>
      index === self.findIndex(d => d.name === dep.name && d.version === dep.version)
    );

    const vulnerabilities: Vulnerability[] = [];
    const outdatedPackages: OutdatedPackage[] = [];
    const licenseIssues: LicenseIssue[] = [];

    // Analyze each dependency
    for (const dep of uniqueDeps) {
      const { name, version } = dep;

      // Check for vulnerabilities
      if (scanOptions.includes("vulnerabilities")) {
        const pkgVulns = MOCK_VULNERABILITIES[name as keyof typeof MOCK_VULNERABILITIES] || [];
        pkgVulns.forEach((vuln, index) => {
          vulnerabilities.push({
            id: `${name}-${version}-${vuln.cve}`,
            package: name,
            version,
            cve: vuln.cve,
            severity: vuln.severity as "critical" | "high" | "medium" | "low",
            cvssScore: vuln.cvssScore,
            description: vuln.description,
            published: vuln.published,
            fixedVersion: vuln.fixedVersion,
            references: vuln.references,
          });
        });
      }

      // Check for outdated packages
      if (scanOptions.includes("outdated")) {
        const latestInfo = MOCK_PACKAGE_VERSIONS[name as keyof typeof MOCK_PACKAGE_VERSIONS];
        if (latestInfo && latestInfo.latest !== version) {
          const updateType = compareVersions(version, latestInfo.latest);
          outdatedPackages.push({
            name,
            currentVersion: version,
            latestVersion: latestInfo.latest,
            type: updateType,
            published: latestInfo.published,
          });
        }
      }

      // Check license compatibility
      if (scanOptions.includes("licenses")) {
        const license = MOCK_LICENSES[name as keyof typeof MOCK_LICENSES] || "UNKNOWN";
        const compatibility = checkLicenseCompatibility(license);

        if (compatibility.compatibility !== "compatible" || compatibility.issues.length > 0) {
          licenseIssues.push({
            package: name,
            license,
            ...compatibility,
          });
        }
      }
    }

    // Calculate risk score (0-10)
    let riskScore = 0;
    riskScore += vulnerabilities.filter(v => v.severity === "critical").length * 3;
    riskScore += vulnerabilities.filter(v => v.severity === "high").length * 2;
    riskScore += vulnerabilities.filter(v => v.severity === "medium").length * 1;
    riskScore += outdatedPackages.filter(p => p.type === "major").length * 1.5;
    riskScore += licenseIssues.filter(l => l.compatibility === "incompatible").length * 2;

    riskScore = Math.min(riskScore, 10);

    const scanTime = Date.now() - startTime;

    const result = {
      totalDependencies: uniqueDeps.length,
      vulnerabilities,
      outdatedPackages,
      licenseIssues,
      riskScore: Math.round(riskScore * 10) / 10,
      scanTime,
    };

    return NextResponse.json(result);
  } catch (error) {
    console.error("Error in dependency vulnerability scanner:", error);
    return NextResponse.json(
      { error: "Failed to scan dependencies" },
      { status: 500 }
    );
  }
}