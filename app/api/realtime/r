import { NextRequest } from "next/server";

export const runtime = "nodejs";

interface Client {
  id: string;
  channel: string;
  userId?: string;
}

const channels = new Map<string, Set<Client>>();

export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const channel = searchParams.get("channel") || "default";
  const clientId = Math.random().toString(36).substring(7);

  // Create a readable stream for SSE
  const stream = new ReadableStream({
    start(controller) {
      const encoder = new TextEncoder();
      
      // Client object
      const client: Client = {
        id: clientId,
        channel,
      };

      // Add client to channel
      if (!channels.has(channel)) {
        channels.set(channel, new Set());
      }
      channels.get(channel)!.add(client);

      console.log(`Client ${clientId} connected to channel: ${channel}`);

      // Send initial connection message
      const connectionMessage = `data: ${JSON.stringify({
        type: "connection",
        data: {
          clientId,
          channel,
          message: `Connected to ${channel} channel`,
          totalClients: channels.get(channel)?.size || 0,
        },
        timestamp: new Date().toISOString(),
      })}\n\n`;

      controller.enqueue(encoder.encode(connectionMessage));

      // Send periodic heartbeats to keep connection alive
      const heartbeatInterval = setInterval(() => {
        try {
          const heartbeat = `data: ${JSON.stringify({
            type: "heartbeat",
            data: { channel },
            timestamp: new Date().toISOString(),
          })}\n\n`;
          controller.enqueue(encoder.encode(heartbeat));
        } catch (error) {
          console.error("Failed to send heartbeat:", error);
          clearInterval(heartbeatInterval);
        }
      }, 30000); // Every 30 seconds

      // Handle client disconnect
      const cleanup = () => {
        clearInterval(heartbeatInterval);
        
        // Remove client from channel
        const channelClients = channels.get(channel);
        if (channelClients) {
          channelClients.delete(client);
          if (channelClients.size === 0) {
            channels.delete(channel);
          }
        }

        console.log(`Client ${clientId} disconnected from channel: ${channel}`);
      };

      // Store cleanup function for when the connection closes
      (controller as any).cleanup = cleanup;
    },

    cancel() {
      // This is called when the client disconnects
      const channelClients = channels.get(channel);
      if (channelClients) {
        channelClients.forEach((client) => {
          if (client.id === clientId) {
            channelClients.delete(client);
            if (channelClients.size === 0) {
              channels.delete(channel);
            }
          }
        });
      }
    },
  });

  return new Response(stream, {
    headers: {
      "Content-Type": "text/event-stream",
      "Cache-Control": "no-cache",
      "Connection": "keep-alive",
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Headers": "Cache-Control",
    },
  });
}

// Helper function to broadcast to a specific channel
export function broadcastToChannel(channel: string, message: any) {
  const channelClients = channels.get(channel);
  if (channelClients && channelClients.size > 0) {
    // In a real implementation, you would push the message to connected clients
    // Since we're using SSE, this would require storing the response streams
    console.log(`Broadcasting to channel ${channel}:`, message);
  }
}

// Helper function to broadcast to all channels
export function broadcastToAll(message: any) {
  channels.forEach((_, channel) => {
    broadcastToChannel(channel, message);
  });
}